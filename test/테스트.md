# 테스트
테스트와 관련된 지식에 대해 정리합니다.

## 테스트의 목표

테스트를 잘 작성하면 설계가 개선되지만 이는 좋은 테스트의 부차적인 기능이다.<br />
**테스트는 비즈니스의 지속적인 성장을 위해 작성하는 것이다.**

## 테스트의 이점
- 회귀에 대한 보험을 제공해준다
- 리팩터링 후 기존 기능을 보장해준다
- 처음 테스트 도입시 시간이 더 걸리지만 이는 프로젝트 후반에 메꾸어지는 비용이다

## 테스트 커버리지
Line coverage: 실행 코드 라인 수 / 전체 라인수<br />
Branch coverage: 통과 분기 수 / 전체 분기 수

테스트 커버리지는 테스트 작성을 위한 자극이 될 수 있지만 목표가 되어서는 안된다.<br />
테스트 커버리지는 얼마든지 조작 가능하다.

```scala
/* 라인 커버리지 50% */
def isStringLong(input: String) = {
  if (input.length > 5) true
  else false
}

/* 라인 커버리지 100% */
def isStringLong2(input: String) =
  input.length > 5

"abc" should "짧은 문자열이다" in {
  val result = isStringLong("abc")
  assertEquals(false, result)
}
```

## 단위 테스트의 세 가지 속성
1. 작은 코드 조각(단위) 검증
2. 빠르게 수행
3. 격리된 방식으로 자동화된 테스트

3번 속성은 사람마다 바라보는 관점이 달라 고전파와 런던파가 나오게 되었다.

## 고전파
모든 사람이 단위 테스트와 테스트 주도 개발에 **원론적**으로 접근하는 방식을 따르길 원해서 고전파(classic)라 부른다.
<br/><br/>
다음의 규칙을 지키면서 테스트를 작성한다.
- 의존성은 **공유 의존성**을 제외하고 전부 **실제 객체**를 사용한다
- **격리 주체는 하나의 테스트이다**
- 테스트는 클래스 하나를 테스트하는 것이 아닌 **하나의 동작**을 테스트한다

## 런던파
런던의 프로그래밍 커뮤니티에서 시작되어 런던파(London)라고 부른다.<br/>
**격리된 방식으로 처리한다**라는 의미를 테스트 대상 시스템(SUT)를 협력자(Collaborator)에게서 격리하는 것으로 이해한다.<br/>
즉, 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이를 모두 테스트 대역(test double)으로 대체한다.
<br/><br/>
다음의 규칙을 지키면서 테스트를 작성한다.
- 의존성은 전부 Mock으로 대체한다
- 검증 단위는 하나의 클래스 또는 함수이다
- 하나의 클래스 단위로 테스트를 격리하고 실행한다

**공유 의존성(shared dependency)**: 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성.<br/>정적 가변 필드, 데이터베이스가 대표적인 예이다.<br/><br/>
**비공개 의존성(private dependency)**: 공유하지 않는 의존성

|               | 격리 주체 | 단위의 크기 | 테스트 대역 사용 대상 |
| ------------- | ------------- | -------------   | ------------- |
| 런던파        | 단위           | 단일 클래스      | 불변 의존성 외 모든 의존성 |
| 고전파        | 단위 테스트    | 단일 or 클래스 셋 | 공유의존성 |

## 테스트의 네가지 속성
1. 회귀 방지
2. 리팩터링 내성
3. 빠른 피드백
4. 유지 보수성

회귀 방지, 리팩터링 내성, 빠른 피드백 세 속성을 모두 만족하게 테스트를 짜는 것은 불가능하다.<br />
리팩터링 내성은 리팩터링하기 쉽거나 어렵거나 이분 선택밖에 없으므로 양보할 수 없는 속성이다.<br />
따라서 회귀 방지와 빠른 피드백에서 균형을 맞춰야 한다.<br />
회귀 방지가 높으면 엔드 투 엔드 테스트, 빠른 피드백이 높으면 단위 테스트가 되고, 절충하면 통합 테스트가 된다.<br />
